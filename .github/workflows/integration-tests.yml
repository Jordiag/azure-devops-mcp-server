on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/**'
      - 'README.md'
      - 'README.*.md'
      - '**/README.md'
      - '**/README.*.md'

  pull_request:
    paths-ignore:
      - '.github/workflows/**'
      - 'README.md'
      - 'README.*.md'
      - '**/README.md'
      - '**/README.*.md'

  workflow_dispatch:

jobs:
  integration-tests:
    runs-on: windows-latest
    env:
      buildPlatform: 'Any CPU'
      buildConfiguration: 'Release'
      solution: 'Dotnet.AzureDevOps.sln'
      sonarProjectKey: 'Jordiag_azure-devops-mcp-server'
      sonarOrganization: 'jordiag-mozcode'
      AZURE_DEVOPS_PAT: ${{ secrets.AZURE_DEVOPS_PAT }}
      AZURE_DEVOPS_PIPELINE_ID: ${{ secrets.AZURE_DEVOPS_PIPELINE_ID }}
      AZURE_DEVOPS_PROJECT_ID: ${{ secrets.AZURE_DEVOPS_PROJECT_ID }}
      AZURE_DEVOPS_REPO_ID: ${{ secrets.AZURE_DEVOPS_REPO_ID }}
      AZURE_DEVOPS_REPOSITORY_ID: ${{ secrets.AZURE_DEVOPS_REPOSITORY_ID }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      AZURE_OPENAI_DEPLOYMENT: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}
      AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
      AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
      AZURE_DEVOPS_BOT_USER_EMAIL: ${{ vars.AZURE_DEVOPS_BOT_USER_EMAIL }}
      AZURE_DEVOPS_BUILD_BRANCH: ${{ vars.AZURE_DEVOPS_BUILD_BRANCH }}
      AZURE_DEVOPS_COMMIT_SHA: ${{ vars.AZURE_DEVOPS_COMMIT_SHA }}
      AZURE_DEVOPS_MAIN_BRANCH_NAME: ${{ vars.AZURE_DEVOPS_MAIN_BRANCH_NAME }}
      AZURE_DEVOPS_ORG_URL: ${{ vars.AZURE_DEVOPS_ORG_URL }}
      AZURE_DEVOPS_SEARCH_ORG_URL: ${{ vars.AZURE_DEVOPS_SEARCH_ORG_URL }}
      AZURE_DEVOPS_ORG:  ${{ vars.AZURE_DEVOPS_ORG }}
      AZURE_DEVOPS_PROJECT_NAME: ${{ vars.AZURE_DEVOPS_PROJECT_NAME }}
      AZURE_DEVOPS_REPO_NAME: ${{ vars.AZURE_DEVOPS_REPO_NAME }}
      AZURE_DEVOPS_SRC_BRANCH: ${{ vars.AZURE_DEVOPS_SRC_BRANCH }}
      AZURE_DEVOPS_TARGET_BRANCH: ${{ vars.AZURE_DEVOPS_TARGET_BRANCH }}
      MCP_SERVER_URL: ${{ vars.MCP_SERVER_URL }}
      OPENAI_MODEL: ${{ vars.OPENAI_MODEL }}
      USE_AZURE_OPENAI: ${{ vars.USE_AZURE_OPENAI }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for SonarCloud analysis
          fetch-tags: true

     
      # ðŸ”Ž Probe tags & compute version candidates (works on pushes and PRs, incl. forks)
      - name: Probe git tags & versions
        id: ver
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          THIS_REPO:  ${{ github.repository }} # owner/name
          HEAD_REPO:  ${{ github.event.pull_request.head.repo.full_name }}
          BASE_REPO:  ${{ github.event.pull_request.base.repo.full_name }}
        run: |
          set -euo pipefail
      
          echo "== Git basics =="
          git --version
          echo "Branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "HEAD:   $(git rev-parse --short HEAD)"
          echo "Remotes:"
          git remote -v || true
      
          echo ""
          echo "== Ensure we have all tags from origin =="
          git fetch --force --tags --prune origin \
            '+refs/heads/*:refs/remotes/origin/*' \
            '+refs/tags/*:refs/tags/*'
          echo "Tag count (origin only): $(git tag | wc -l || echo 0)"
      
          # If this is a PR from a fork, also fetch tags from the base repo
          if [[ "${EVENT_NAME}" == "pull_request" ]] && [[ -n "${HEAD_REPO:-}" ]] && [[ -n "${BASE_REPO:-}" ]] && [[ "${HEAD_REPO}" != "${BASE_REPO}" ]]; then
            echo ""
            echo "== PR from fork detected =="
            echo "Head repo: ${HEAD_REPO}"
            echo "Base repo: ${BASE_REPO}"
            if ! git remote get-url upstream >/dev/null 2>&1; then
              git remote add upstream "https://github.com/${BASE_REPO}.git"
            fi
            git fetch --force --tags --prune upstream '+refs/tags/*:refs/tags/*'
            echo "Tag count after fetching upstream: $(git tag | wc -l || echo 0)"
          fi
      
          echo ""
          echo "== Sample of newest tags by creation date =="
          git tag --list --sort=-creatordate | head -n 15 || true
      
          echo ""
          echo "== Strategies =="
          # 1) Nearest reachable plain tag from HEAD
          REACHABLE="$(git describe --tags --abbrev=0 2>/dev/null || true)"
          echo "Reachable (git describe --tags --abbrev=0): ${REACHABLE:-<none>}"
      
          # 2) Nearest description (may include distance/sha)
          NEAREST_DESC="$(git describe --tags --always 2>/dev/null || true)"
          echo "Nearest description (git describe --tags --always): ${NEAREST_DESC:-<none>}"
      
          # 3) Most recently created tag (not limited to HEAD ancestry)
          NEWEST_CREATED="$(git tag --list --sort=-creatordate | head -n1 || true)"
          echo "Newest by creation date: ${NEWEST_CREATED:-<none>}"
      
          # 4) Highest SemVer tag (ignores non-SemVer tags)
          HIGHEST_SEMVER="$(
            git tag -l \
              | grep -E '^[vV]?[0-9]+\.[0-9]+\.[0-9]+$' \
              | sed -E 's/^[vV]//' \
              | awk -F. '{printf("%d.%d.%d %s\n",$1,$2,$3,$0)}' \
              | sort -n -k1 -k2 -k3 \
              | awk '{print $4}' \
              | tail -n1
          )"
          echo "Highest SemVer: ${HIGHEST_SEMVER:-<none>}"
      
          echo ""
          echo "== Normalisation and selection =="
          # Helper: strip leading v/V
          clean() { printf "%s" "${1:-}" | sed -E 's/^[vV]//' ; }
      
          CANDIDATES=()
          [[ -n "${REACHABLE:-}"      ]] && CANDIDATES+=("$(clean "$REACHABLE")")
          [[ -n "${NEWEST_CREATED:-}" ]] && CANDIDATES+=("$(clean "$NEWEST_CREATED")")
          [[ -n "${HIGHEST_SEMVER:-}" ]] && CANDIDATES+=("$(clean "$HIGHEST_SEMVER")")
      
          BASE=""
          for c in "${CANDIDATES[@]:-}"; do
            if [[ "$c" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then BASE="$c"; break; fi
          done
          BASE="${BASE:-0.0.0}"
          BUILD="${GITHUB_RUN_NUMBER}"
          FULL="$BASE.$BUILD"
          INF="$FULL+${GITHUB_SHA::7}"
      
          echo "Chosen BASE: $BASE"
          echo "Assembly/File: $FULL"
          echo "Informational: $INF"
      
          echo ""
          echo "== Final checks =="
          echo "Tags reachable from current HEAD:"
          git tag --points-at HEAD || true
      
          echo "::group::Summary (copy-paste)"
          echo "REACHABLE=${REACHABLE:-}"
          echo "NEWEST_CREATED=${NEWEST_CREATED:-}"
          echo "HIGHEST_SEMVER=${HIGHEST_SEMVER:-}"
          echo "BASE=$BASE"
          echo "FULL=$FULL"
          echo "INFORMATIONAL=$INF"
          echo "::endgroup::"
      
          # Outputs (optional for subsequent steps)
          {
            echo "base=$BASE"
            echo "full=$FULL"
            echo "informational=$INF"
          } >> "$GITHUB_OUTPUT"


      - name: Ensure tags
        shell: bash
        run: git fetch --force --tags --prune

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.x'

      - name: Install NuGet
        uses: NuGet/setup-nuget@v1

      - name: Install SonarCloud Scanner for .NET
        run: dotnet tool install --global dotnet-sonarscanner

      - name: Install Coverage Tool
        run: dotnet tool install --global dotnet-coverage

      - name: Set cache date
        id: cache-date
        run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ steps.cache-date.outputs.date }}
          restore-keys: |
            nuget-${{ runner.os }}-
            nuget-

      - name: Restore NuGet packages
        run: nuget restore "${{ env.solution }}"
      
      - name: Set Sonar PR Analysis Parameters (if pull_request)
        if: github.event_name == 'pull_request'
        run: |
          dotnet sonarscanner begin `
            /k:"${{ env.sonarProjectKey }}" `
            /o:"${{ env.sonarOrganization }}" `
            /d:sonar.token="${{ secrets.SONAR_TOKEN }}" `
            /d:sonar.host.url="https://sonarcloud.io" `
            /d:sonar.cs.vscoveragexml.reportsPaths="coverage.xml" `
            /d:sonar.dotnet.excludeTestProjects=true `
            /d:sonar.pullrequest.key="${{ github.event.pull_request.number }}" `
            /d:sonar.pullrequest.branch="${{ github.head_ref }}" `
            /d:sonar.pullrequest.base="${{ github.base_ref }}"
        shell: pwsh

    # -- Sonar Begin (Non-PR: workflow_run or manual) --
      - name: Begin SonarCloud Analysis (Non-PR)
        if: github.event_name != 'pull_request'
        run: |
          dotnet sonarscanner begin `
            /k:"${{ env.sonarProjectKey }}" `
            /o:"${{ env.sonarOrganization }}" `
            /d:sonar.token="${{ secrets.SONAR_TOKEN }}" `
            /d:sonar.host.url="https://sonarcloud.io" `
            /d:sonar.cs.vscoveragexml.reportsPaths="coverage.xml" `
            /d:sonar.dotnet.excludeTestProjects=true
      
      - name: Build with Dotnet
        shell: pwsh
        run: dotnet build "${{ env.solution }}" -c "${{ env.buildConfiguration }}" --no-restore `
          -p:Version=${{ steps.ver.outputs.base }} `
          -p:AssemblyVersion=${{ steps.ver.outputs.full }} `
          -p:FileVersion=${{ steps.ver.outputs.full }} `
          "-p:InformationalVersion=${{ steps.ver.outputs.Informational }}"

      - name: Run Tests with Coverage
        run: |
          dotnet test "${{ env.solution }}" `
            -c "${{ env.buildConfiguration }}" `
            --filter "TestType!=End2End" `
            --no-restore --no-build `
            --settings "${{ github.workspace }}/.runsettings" `
            --collect:"Code Coverage" `
            --results-directory ./TestResults/ `
            --logger "trx"
        shell: pwsh
        continue-on-error: false

      - name: Convert Coverage to XML
        run: |
          dotnet-coverage merge ./TestResults/**/*.coverage --output coverage.xml --output-format xml
        shell: pwsh
        continue-on-error: false

      - name: End SonarCloud Analysis
        run: dotnet sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

